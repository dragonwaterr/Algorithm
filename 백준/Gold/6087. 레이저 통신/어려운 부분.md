# 기존 로직
```java
// 노드가 큐에 들어갈지 판단할 메서드
static boolean isMovable(Node cur) {
        int row = cur.row;
        int col = cur.col;
        if(row == 0 || row == graph.length - 1
            || col == 0 || col == graph[0].length - 1) return false; // 그래프를 벗어남
        if(graph[row][col] == '*') return false; // 벽
        return mirrors[row][col] >= cur.mirror; // 저장된 최소 꺾기 이하로 꺾음 -> 메모리 초과 발생 원인
}
```

## 메모리 초과 발생
### 원인
- 지나온 경로는 다른데, 어느 순간 이후부터는 완전히 동일한 노드가 중복돼서 큐에 들어갔다.(마주친 거울 개수와 위치, 현재 바라보는 방향이 모두 동일한 노드)
```java
return mirrors[row][col] >= cur.mirror; // 저장된 최소 꺾기 이하로 꺾음 -> 메모리 초과 발생 원인
```
- 초기 아이디어는 " >= " 로 비교 : 동일한 거울 개수를 지나쳤음에도 특정 위치에 도달했을 때의 방향이 다르면 다음에 어떤 방향으로 꺾냐에 따라 또 다른 노드가 되기 때문
- 이 조건식은 노드의 중복 offer 막을 수 없음

### 현상을 확인한 테스트케이스
```
100 7
...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*
C*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*.*
...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*
**************************************************************************************************.*
...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*
C*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*.*
...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*
```

# 수정 로직
```java
// 좌표까지 도달할 때 사용한 거울의 최솟값을 저장하는 배열
mirrors = new int[h+2][w+2][4]; // 수정한 부분 1

static boolean isMovable(Node cur) {
        ...
        return mirrors[row][col][cur.past] > cur.mirror; // 수정한 부분 2
}
```
- 최소 거울 수를 갱신할 때, 노드가 진행되는 방향을 고려하도록 3차원 배열로 처리
- 진행 방향에 따라 최솟값을 따로 저장해서 해결
