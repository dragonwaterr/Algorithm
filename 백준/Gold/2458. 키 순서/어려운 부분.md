## 생각해 내기 어려웠던 부분
1. "A 가 B 보다 크다 or 뒤에 있다" 와 같은 대소, 선후 관계를 플로이드-워셜 알고리즘으로 파악할 수 있다.
- 알고리즘의 의도는 (모든 노드 -> 모든 노드) 의 최소 비용의 계산이지만, A -> B 의 관계에 대해 graph[A][B] 에 1 을 넣음으로써 직접 경로가 있음을 표시할 수 있다.
- 값이 1 이라면 직접 경로를 의미하고, 값이 2 라면 중간에 노드 하나가 있음을 의미한다. (아래 플로이드 알고리즘 코드 일부분을 참고)

```java
if (graph[i][j] > graph[i][k] + graph[k][j])
    graph[i][j] = graph[i][k] + graph[k][j];

// 초기에 주어지는 모든 경로를 1로 저장한다면, 이미 있던 경로끼리 더해진다고 하더라도 그들이 거친 노드 숫자만큼 
```

2. "내가 줄에서 몇 번째에 서있는지를 정확하게 알아낼 수 있는가 ?" 를 알아내기
- 알아낼 수 있다 == 전체 사람수가 n 명일 때, 나보다 앞에 있는 사람의 숫자 p1 과 뒤에 있는 사람 숫자 p2 의 합이 n-1 이다.
- 뒤에 있는 사람 수와 앞에 있는 사람 수를 구하는 방법 ?
  - 대소, 선후 관계를 표현했기 때문에, graph[a][b] != INF 라면 graph[b][a] == INF 가 보장된다 !
  - 활용 예시) 4번 노드의 앞, 뒤에 있는 노드 숫자를 각각 구해보자
    - 4번 보다 앞에 있는 노드는 graph[x][4] != INF 인 x 의 개수 = p1 
    - 4번 보다 뒤에 있는 노드는 graph[4][y] != INF 인 y 의 개수 = p2
    - ##### p1 + p2 == n-1 이라면 4번 노드의 순서는 p1 + 1 번째로 확정할 수 있다 ! 
